---
title: Using the Pivotal Build Service CLI
owner: Build Service Team
---

This topic describes how to use the Pivotal Build Service CLI, `pb`, to log in to Build Service, create and delete container images, create and delete teams, and manage builds.

## <a id='configure-cli'></a> Log In to Build Service

After you configure and install Build Service, you can configure the Build Service CLI, `pb`, to target your Build Service installation and log in.

For more information about installation and configuring Build Service, see [Installing and Configuring Build Service](./installing.html). 

To target your Build Service installation and log in:

1. Target the API for your Build Service installation:

    ```bash
    pb api set YOUR-BUILD-SERVICE-API
    ```
    Where `YOUR-BUILD-SERVICE-API` is the URL for the API for your Build Service installation. For example, `https://build-service.example.com`.
    <p class="note"><b>Note:</b> Use the <code>--skip-ssl-validation</code> flag if your Build Service installation targets a UAA that has a self-signed CA cert.</p>

1. Confirm that you targeted the correct Build Service installation:

    ```bash
    pb api get
    ```

1. Log in to Build Service:

    ```bash
    pb login
    ```
1. When prompted, enter the `username` and `password` for UAA. 

The username and password can be passed to Build Service with the following environment variables:
`BUILD_SERVICE_USERNAME` and `BUILD_SERVICE_PASSWORD`. The CLI will default to pick these up and use them if they exist in the environment.


## <a id='manage-teams'></a> Manage Teams

The following procedures describe how to manage teams and users with the `pb` CLI.

### <a id='create-team'></a> Create a Team

A `team` is a Build Service entity that uses UAA to provide user access control to image configurations. For more information, see [Build Service Teams](./installing.html/#team-config).

To create a new team: 

1. Log in to Build Service:

    ```bash
    pb login
    ```

1. Create a new team:

    ```
    pb team create TEAM-NAME
    ```
    Where `TEAM-NAME` is a unique name for the team.  


### <a id='manage-team-members'></a> Add and Remove Team Members

All members of a team can add and remove team members. 

To add members to a team:

1. Log in to Build Service:

    ```bash
    pb login
    ```

1. Add a user to a team:
    ```
    pb team user add UAA-USER-EMAIL TEAM-NAME
    ```
    Where:
    * `UAA-USER-EMAIL`: Is the email address for the user.
    <p class="note"><b>Note:</b> The user email address must be in UAA to add the user to a team.</p>
    * `TEAM-NAME` is the name of the team where the user is added.

To remove members of a team:

1. Log in to Build Service:

    ```bash
    pb login
    ```

1. Remove a user from a team:

    ```
    pb team user remove UAA-USER-EMAIL TEAM-NAME
    ```
    Where:
    * `UAA-USER-EMAIL`: Is the email address for the user.
    * `TEAM-NAME` is the name of the team from which the user is removed.

### <a id='add-image'></a> Associate Image Registry with a Team    

Next, to effectively utilize the team they created, users must associate image registry credentials and git credentials (if the source code lives in a private git repo) with the team.

Build Service will utilize these credentials to deliver container image builds to the user's specified registry.  The registry credential provided should belong to a user with `write` access on the registry. Currently, build service has tested and recommends using Docker Hub, GCR, Harbor, or Artifactory.  

Since Docker Hub and GCR are hosted services, when referencing these registries in the `registry` field, use the domain names `index.docker.io` and `gcr.io` respectively.  For Artifactory or Harbor, reference the domain that is specific to your deployment of the registry.

To associate an image registry credentials with a team:

1. Add image registry credentials to the team:

    ```yaml
    team: example-team-name
    registry: registry.default.com
    username: <registry username>
    password: <registry password>
    ```

    And then run
    ```
    pb secrets registry apply -f path/to/<example-registry-creds>.yaml
    ```
    <br><br>**Current Constraints**
      * Users can only add a secret at a time
      * The registry credential that a given team uses can be updated by modifying the above file and running the `pb secrets registry apply` command.

### <a id='add-git-credentials'></a> Manage Git Credentials for a Team

To allow Build Service to execute builds against app source code in a private Git repository, add the Git username and password to the team that manages the source code in Build Service.

<p class="note"><strong>Note</strong>: The git secret a given team uses can be updated by modifying the above file and running the <code>pb secrets git apply</code> command.</p>

As you apply the registry and git secret files, the `pb` CLI will provide feedback indicating whether or not the commands succeeded.

#### Add Git Credentials to a Team

To add git credentials to a team:

1. Create a YAML file with the `git` credentials:

    ```yaml
    team: TEAM-NAME
    repository: github.com
    username: GIT-USERNAME
    password: GIT-PASSWORD
    ```
1. Apply the git credentials to the team:
    
    ```
    pb secrets git apply -f PATH-TO-GIT-CREDENTIALS-YAML-FILE
    ```

#### Delete Git Credentials From a Team

1. 

    ```
    pb secrets registry delete <name-of-registry.io> -t example-team-name
    ```
1. 

    ```
    pb secrets git delete github.com -t example-team-name
    ```

### <a id='delete-team'></a> Delete a Team

```bash
pb team delete <team-name>
```
If the operation is successful, the CLI will display the message: `Successfully deleted team <team-name>`

Deleting a team will also delete any registry credentials and git secrets associated with that team.

Teams **CANNOT** be deleted if they have images on Pivotal Build Service that belong to them. A team can be deleted only once all images owned by the team on Pivotal Build Service have been deleted.


## <a id='create-image'></a> Creating an image

An image defines the specification that Pivotal Build Service uses to create images for a user. Here is an example of an image configuration:

```yaml
team: example-team-name
source:
  git:
    url: https://github.com/example-org/sample-java-app
    revision: master
build:
  env:
  - name: BP_JAVA_VERSION
    value: 8.*
image:
  tag: registry.default.com/my-team-folder/java-app-image
```

It is composed of the following components:

1. The `team` that the image belongs to. It has to be the team you are a part of as well. You can only create images for teams you belong to.
1. The `source` defines the git location of the code that images will be built against. The `revision` can either be a branch, tag or a commit-sha. When targeted against a branch, a build is triggered for every new commit.
1. The `build` defines additional configuration you would like your app to be built with.  The `env` is a list of environment variables that will be provided to the build. Each environment variable is an object with `name` and `value`.
1. An `image registry` defines the destination registry of the builds for the image. The credentials for the target registry must be specified in the `registries` section of the team configuration. This should also match the domain of one of the registries provided in the team configuration.

The value of `image.tag` will be used to refer to the image once it has been created within Pivotal Build Service. Updating this field will lead to the creation of a new image.

The above image configuration can be saved as `<my-example-image>.yaml`

**Creating an `image` against source code in a git repo**

The above configuration of the image can be applied to Pivotal Build Service:

```bash
pb image apply -f /path/to/<my-example-image>.yaml
```

**Creating an image using local source code**

Build Service supports builds against source code that lives in a git repository or locally on a users machine.  However, users can only specify one source code location.  To replicate the above image creation workflow using local source code, users can modify the file by removing the git fields.  The resulting file would look like this:

```yaml
team: example-team-name
build:
  env:
  - name: BP_JAVA_VERSION
    value: 8.*
image:
  tag: registry.default.com/my-team-folder/sample-java-app
```

Users would apply this image configuration and specify a path to their application.

```bash
pb image apply -f /path/to/<my-example-image>.yaml -p /path/to/app_directory
```

## <a id='rebuild-image'></a> Rebuilds

Pivotal Build Service auto-rebuilds images when one or more of the following build inputs change:
1. New buildpack versions are made available through an updated builder image
1. New commit on a branch or tag Pivotal Build Service is tracking
1. Updating the commit, branch, git repo, or build fields on the image's configuration file and re-applying it via `pb image apply`
1. Uploading a new copy of local source via `pb image apply -p`

**Current Constraints:**

* Pivotal Build Service does not rebuild images based on new OS packages (like cflinuxfs3)

## <a id='monitor-builds'></a> Monitoring builds for an image

You can list all the builds created for an image with:

```bash
pb image builds <image-tag>
```

The `<image-tag>` in the above command is the value of the field `image.tag` in the image's configuration. The output of the command might look similar to what's described below:

```
Build    Status    Started Time           Finished Time          Reason    Digest
-----    ------    ------------           -------------          ------    ------
    1    SUCCESS   2019-09-09 21:55:27    2019-07-08 21:56:54    CONFIG    *************************************************
    2    SUCCESS   2019-09-09 21:56:55    2019-07-08 21:57:40    COMMIT    *************************************************
    3    FAILED    2019-09-09 21:58:55    2019-07-08 21:59:40    CONFIG+   --
    4    BUILDING  2019-09-09 21:58:55    --                     BUILDER   --
    -    PENDING   --                     --                     UNKNOWN   --
```

  1. The `Build` column describes the index of builds in the order that they were built.
  1. The `Status` column describes the status of a previous or a running/pending build image.
  1. The  `Started Time` and `Finished Time` columns described when a build was kicked off and when it was completed.
  1. The `Reason` column provides the user with information as to why an image rebuild occured. These reasons include
      * `CONFIG`
          * Occurs when a change is made to commit, branch, git repo, or build fields on the image's configuration file and the user ran `pb image apply`
      * `COMMIT`
          * Occurs when new source code is committed to a branch or tag build service is monitoring for changes
      * `BUILDER`
          * Occurs when new buildpack versions are made available through an updated builder image
          <p class="note"><strong>Note</strong>: It is possible for a rebuild to occur for more than one <code>Reason</code>. In this instance, a <code>+</code> sign is appended to the <code>Reason</code> and the primary <code>Reason</code> is displayed. Priority for the <code>Reason</code> is ranked <code>CONFIG</code>, <code>COMMIT</code>, <code>BUILDER</code>, in descending order.</p>
  1. The `Digest` column contains the SHA256 of the image successfully built.  Users can reference this SHA to perform helpful Docker commands like `pull` and `inspect`

**Retrieving logs of a particular build**

```bash
pb image logs <image-tag> -b <build-number>
```

The output of the command will look similar to this:

```
[build-step-credential-initializer] {"level":"info","ts":1562684107.3441668,"logger":"fallback-logger","caller":"creds-init/main.go:40","msg":"Credentials initialized.","commit":"002a41a"}
[build-step-credential-initializer]
[build-step-git-source-0] git-init:main.go:81: Successfully cloned "https://github.com/buildpack/sample-java-app" @ "abde24efc17802b7e2b3814e0ead63a460e66f5f" in path "/workspace"
[build-step-git-source-0]
[build-step-prepare]
[build-step-detect] Trying group 1 out of 3 with 27 buildpacks...
[build-step-detect] ======== Results ========
[build-step-detect] skip: Cloud Foundry Archive Expanding Buildpack
[build-step-detect] pass: Pivotal OpenJDK Buildpack
[build-step-detect] pass: Pivotal Build System Buildpack
[build-step-detect] pass: Cloud Foundry Spring Boot Buildpack
[build-step-detect] pass: Cloud Foundry Apache Tomcat Buildpack
...
[build-step-detect] skip: Cloud Foundry JMX Buildpack
[build-step-detect] pass: Cloud Foundry Spring Auto-reconfiguration Buildpack
[build-step-detect]
[build-step-restore] Restoring cached layer 'io.pivotal.openjdk:openjdk-jdk'
...
[build-step-restore] Restoring cached layer 'org.cloudfoundry.springboot:spring-boot'
[build-step-restore]
[build-step-analyze] Analyzing image 'registry.com/sample/demo@sha256:8ff708081ee10f7039f77275f1e6eb6359cae8d90028c79a5c493ced0dc63f68'
[build-step-analyze] Using cached layer 'io.pivotal.openjdk:openjdk-jdk'
...
[build-step-analyze] Rewriting metadata for layer 'org.cloudfoundry.springboot:spring-boot'
[build-step-analyze] Writing metadata for uncached layer 'io.pivotal.clientcertificatemapper:client-certificate-mapper'
[build-step-analyze] Writing metadata for uncached layer 'org.cloudfoundry.springautoreconfiguration:auto-reconfiguration'
[build-step-analyze]
[build-step-build]
[build-step-build] Pivotal OpenJDK Buildpack 1.0.0-M9
[build-step-build]   OpenJDK JDK 11.0.3: Reusing cached layer
[build-step-build]   OpenJDK JRE 11.0.3: Reusing cached layer
[build-step-build]   JVMKill Agent 1.16.0: Reusing cached layer
[build-step-build]   Class Counter 1.0.0-M9: Reusing cached layer
[build-step-build]   Memory Calculator 4.0.0: Reusing cached layer
[build-step-build]
...
[build-step-build]     task:        java -cp $CLASSPATH $JAVA_OPTS io.buildpacks.example.sample.SampleApplication
[build-step-build]     web:         java -cp $CLASSPATH $JAVA_OPTS io.buildpacks.example.sample.SampleApplication
[build-step-build]
[build-step-build] Pivotal Client Certificate Mapper Buildpack 1.0.0-M9
[build-step-build] Cloud Foundry Spring Auto-reconfiguration Buildpack 1.0.0-M9
[build-step-build]   Spring Auto-reconfiguration 2.7.0: Reusing cached layer
[build-step-build]
[build-step-export] Reusing layers from image 'index.docker.io/matthewmcnew/demo@sha256:8ff708081ee10f7039f77275f1e6eb6359cae8d90028c79a5c493ced0dc63f68'
[build-step-export] Reusing layer 'app' with SHA sha256:02e0070ce11bac1829174ec1296dcb1f3f04a4c30a958e2c41ad5498f78898fe
...
[build-step-export] Reusing layer 'org.cloudfoundry.springautoreconfiguration:auto-reconfiguration' with SHA sha256:93d94baf6d0dfc4981eb7d8ddfc4ae51f5c13cf87789b64ae8c4b015318a1b43
[build-step-export] *** Images:
[build-step-export]       registry.com/sample/demo:latest - succeeded
[build-step-export]       registry.com/sample/demo:b2.20190709.145448 - succeeded
[build-step-export]
[build-step-export] *** Digest: sha256:48a4ca8e4d8e8a9af26437588d0ce0e9d5c09b53aeb3ef64230a3d58d4b0dc90
[build-step-export]
[build-step-cache] Reusing layer 'io.pivotal.openjdk:openjdk-jdk' with SHA sha256:5554c7c06a266eb44a7cbdf0ecfaa14070e21af2b0bdfd1edd3b96f5168cd511
[build-step-cache] Reusing layer 'io.pivotal.buildsystem:build-system-cache' with SHA sha256:3b03fdd870a2dc1e924a040b604c25b76efafc1324ceb08eae8eae686fc3a940
...
[build-step-cache] Reusing layer 'org.cloudfoundry.springboot:spring-boot' with SHA sha256:effa8b80729cafa9f9a01b21a4badb5203510de0bb2e6b309ffd2593b0a28de7
[build-step-cache]
```

This is the output of a successful build. Failed builds should indicate the reason of the failure in the logs.

The logs for a running build can be followed by using the `-f` flag, much like this:

```bash
pb image logs <image-tag> -b <build-number> -f
```
This should follow along with the progress of the build and terminate when the build completes.

**Current Constraints:**

* Pivotal Build Service only stores the ten most recent successful builds and ten most recent failed builds.
* Users cannot retrieve logs by referencing the image digest, they must use the build number

## <a id='delete'></a> Deleting teams and images

**Delete `image`**

The commands to delete a team and an image are similar to each other. To delete an image run:

```bash
pb image delete <image-tag>
```

If the operation is successful, the CLI will display the message: `Successfully deleted image <image-tag>`

This will delete all the builds that belong to the Pivotal Build Service image. This **WILL NOT** delete the images that have been generated by those builds. To delete those images, one would have to delete each of them manually from the registry.

Similarly, team deletion can be performed using:


