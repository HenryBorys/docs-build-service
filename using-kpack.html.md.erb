---
title: Tutorial for kpack
owner: Build Service Team
---

This topic describes how to get started with kpack, a collection of open source resource controllers and CRDs that contain declarative build logic.


## <a id='prerequistites'></a> Prerequisites

This documentation assumes you have kpack installed, as well as the following:

* A Kubernetes cluster. To create a Kubernetes cluster, see [Using Minikube to Create a Cluster
](https://kubernetes.io/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/) in the Kubernetes documentation.

* The `kubectl` CLI. To download the `kubectl` CLI, see [Install and Set Up kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/) in the Kubernetes documentation.

* A Docker v2 registry. To create and run a Docker registry, see [Docker Registry](https://docs.docker.com/registry/) in the Docker documentation.


## <a id='image-resource'></a> The Image Resource

A declarative build system is a system to which you declare the desired result of a build, which the system then builds on its own without direction. For example, when you give the system the names of the libraries a project depends upon, the system fetches the libraries and finds the source classes on its own. This is different from an imperative build system, which requires you to run commands to tell it how to do what you want to accomplish.

The `image` resource is what kpack utilizes to declaratively build app images. The following defines the relevant fields of the `image` resource spec in more detail:

- `tag`: The image tag.
- `builder`: Configuration of the `builder` resource the image builds use. For more information, see [Builder Configuration](#builder-config).
- `serviceAccount`: The service account name that is used for credential lookup.
- `source`: The source code that is monitored and built into images. For more information, see [Source Configuration](#source-config).
- `cacheSize`: The size of the Volume Claim that the build cache uses.
- `failedBuildHistoryLimit`: The maximum number of failed builds for an image that is retained.
- `successBuildHistoryLimit`: The maximum number of successful builds for an image that is retained.
- `imageTaggingStrategy`: Allow for builds to be additionally tagged with the build number. Valid options are `None` and `BuildNumber`.
- `build`: Configuration that is passed to every image build. For more information, see [Build Configuration](#build-config).

### <a id='builder-config'></a> Builder Configuration

The `builder` field describes the builder that builds the OCI images for a provided image configuration. It can be defined in one of the following ways:

* Cluster builder

    ```
    yaml
    builder:
        name: CLUSTER-BUILDER-NAME
        kind: ClusterBuilder
    ```
    Where:
    * `name` The name of the ClusterBuilder resource in Kubernetes.
    * `kind` is the type as defined in Kubernetes. This value is always ClusterBuilder.

* Namespaced builder

    ```
    yaml
    builder:
        name: BUILDER-NAME
        kind: Builder
    ```
    Where:
    * `name` is the name of the Builder resource in Kubernetes.
    * `kind` is the type as defined in Kubernetes. This value is always Builder.

<p class='note'><strong>Note:</strong> This image can only reference builders defined in the same namespace. This is not true for ClusterBuilders because they are not namespace-scoped.</p>

### <a id='source-config'></a> Source Configuration

The `source` field is a composition of a source code location and a `subpath`. It can be configured in one of the following ways:

* Git

    ```
    yaml
    source:
      git: GIT-REPOSITORY
        url: GIT-REPOSITORY-URL
        revision: GIT-REVISION
      subPath: SUBDIRECTORY
    ```
    Where:
    * `GIT-REPOSITORY` is the Git repository that contains the source code.
    * `GIT-REPOSITORY-URL` is the Git repository URL. Currently, only HTTPS repositories are supported.
    * `GIT-REVISION` is the Git revision you want to use. This value may be a commit SHA, branch name, or tag.
    * `SUBDIRECTORY` is a subdirectory within the source folder where the app code resides. This can be ignored if the source code resides at the `root` level.

* Blob

    ```
    yaml
    source:
      blob: BLOB
        url: BLOB-URL
      subPath: SUBDIRECTORY
    ```
    Where:
    * BLOB is the blob in a blobstore that contains the source code.
    * BLOB-URL is the URL of the source code blob. Either this blob must be publicly accessible, the access token must be contained in the URL.
    * SUBDIRECTORY is the subdirectory within the source folder where the app code resides. This can be ignored if the source code resides at the `root` level.

* Registry

    ```
    yaml
    source:
      registry: OCI-IMAGE
        image: IMAGE-LOCATION
        imagePullSecrets:
        - name: SECRET-NAME-LIST
      subPath: SUBDIRECTORY
    ```
    Where:
    * OCI-IMAGE is the OCI image in a registry that contains the source code.
    * IMAGE-LOCATION is the location of the source image.
    * SECRET-NAME-LIST is a list of `dockercfg` or `dockerconfigjson` secret names. This is required if the source image is private.
    * SUBDIRECTORY is a subdirectory within the source folder where the app code resides. This can be ignored if the source code resides at the `root` level.

### <a id='build-config'></a> Build Configuration

The `build` field on the `image` resource can be used to configure environment variables required during the build process and to configure resource limits on `CPU` and `memory`.

```
yaml
build:
  env:
    - name: ENV-VAR-NAME
      value: ENV-VAR-VALUE
  resources:
      limits:
        cpu: "0.25"
        memory: "128M"
      requests:
        cpu: "0.5"
        memory: "256M"
```
Where:
* ENV-VAR-NAME is the name of the environment variable.
* ENV-VAR-VALUE is the value of the environment variable.
* CPU

For more information about setting environment variables, see [Define Environment Variables for a Container](https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/) and the [Resource requests and limits of Pod and Container](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container) section of the _Managing Compute Resources for Containers_ topic in the Kubernetes documentation.

### <a id='create-builder'></a> Creating a Builder Resource

There are two different Builder resources that kpack supports. You must create these Builder resources before you create any Image Resource, because they define which Builder is used to create these images.

* Namespaced Builder: This is a Builder that exists inside a namespace and cannot be shared between namespaces. This property allows you to push the image of the Builder to a private registry by giving the option to set `ImagePullSecret`. See the following example:

    ```
    yaml
    apiVersion: build.pivotal.io/v1alpha1
    kind: Builder
    metadata:
      name: sample-builder
      namespace: some-namespace
    spec:
      image: cloudfoundry/cnb:bionic
      updatePolicy: polling
      # imagePullSecrets: # Use these secrets if credentials are needed to pull the builder
      # - name: builder-secret
    ```
    Where:
    - `name`: The name of the builder that will be used to reference by the image.
    - `namespace`: Namespace where the builder builder will be created
    - `image`: Builder image tag.
    - `updatePolicy`: Update policy of the builder. Valid options are `polling` and `external`
    The major difference between the options is that `external` require a user to update the resource by applying a new
    configuration. While `polling` automatically checks every 5 minutes to see if a new version of the builder image exists
    - `imagePullSecrets`: This is an optional parameter that should only be used if the builder image is in a
    private builder. [To create this secret please reference this link](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials)

* Cluster Builder
    This type of Builder can be used by used inside any namespace. A caveat of having a cluster builder is that
    the image need to exist in a publicly accessible registry.
        Next you can find an example on how to create this resource

        ```yaml
        apiVersion: build.pivotal.io/v1alpha1
        kind: ClusterBuilder
        metadata:
          name: sample-cluster-builder
        spec:
          image: cloudfoundry/cnb:bionic
          updatePolicy: polling
        ```
        - `name`: The name of the builder that will be used to reference by the image.
        - `namespace`: Namespace where the builder builder will be created
        - `image`: Builder image tag.
        - `updatePolicy`: Update policy of the builder. Valid options are `polling` and `external`
        The major difference between the options is that `external` require a user to update the resource by applying a new
        configuration. While `polling` automatically checks every 5 minutes to see if a new version of the builder image exists


## <a id='create-image'></a> Creating an Image Resource

There are several resource types that will work together to produce an image resource.  Below, we will review how to configure and create each resource. Note that the yaml resources contain a `name` field. Users should reference these names when configuring other resource types. In order to apply a particular resource type, use `kubectl apply -f ~/path/to/resource.yml`

1. Create a namespace. This defines the partition inside which all of the builds will run.

```yaml
apiVersion: v1
kind: Namespace
metadata:
    name: build-namespace
```

1. Create a secret so that kpack can push image builds to your desired registry. The `name` of this credential will be referenced to create a service account.

    1. GCR example

    ```yaml
    apiVersion: v1
    kind: Secret
    metadata:
     name: basic-auth-gcr
     namespace: build-namespace
     annotations:
       build.pivotal.io/docker: gcr.io
    type: kubernetes.io/basic-auth
    stringData:
     username: <username>
     password: <password>
    ```

    1. Docker Hub example

    ```yaml
    apiVersion: v1
    kind: Secret
    metadata:
     name: basic-auth-docker
     namespace: build-namespace
     annotations:
       build.pivotal.io/docker: index.docker.io
    type: kubernetes.io/basic-auth
    stringData:
     username: <username>
     password: <password>
    ```

1. Create a secret for pull access from the desired git repository. The example below is for a github repository.
You can also specify a personal access token. If you are building against source code that lives in a public registry,
you do not need to configure a git secret.  The `name` of this credential will be referenced to create a service account (step 4).

    ```yaml
    apiVersion: v1
    kind: Secret
    metadata:
      name: basic-git-user-pass
      namespace: build-namespace
      annotations:
        build.pivotal.io/git: https://github.com
    type: kubernetes.io/basic-auth
    stringData:
      username: <username>
      password: <password>
    ```

1. Create a service account that uses the docker registry secret and the git repository secret.
When configuring the image resource, reference the `name` of your registry credential and the `name` of your git credential.

    ```yaml
    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: service-account
      namespace: build-namespace
    secrets:
      - name: basic-docker-user-pass
      - name: basic-git-user-pass
    ```

1. Apply an image configuration to the cluster. In addition to specifying the source code url and any build time
environment variable names and values your app needs, users can also exercise additional control over how kpack
executes builds. Users can do this by specifying cache size, build history limit, and resources used.

    If you would like to build an image from a git repo:

    ```yaml
    apiVersion: build.pivotal.io/v1alpha1
    kind: Image
    metadata:
      name: sample-image
      namespace: build-namespace
    spec:
      tag: gcr.io/project-name/app
      serviceAccount: service-account
      builder:
        name: sample-builder
        kind: ClusterBuilder
      cacheSize: "1.5Gi" # Optional, if not set then the caching feature is disabled
      failedBuildHistoryLimit: 5 # Optional, if not present defaults to 10
      successBuildHistoryLimit: 5 # Optional, if not present defaults to 10
      source:
        git:
          url: https://github.com/buildpack/sample-java-app.git
          revision: master
      build: # Optional
        env:
          - name: BP_JAVA_VERSION
            value: 8.*
        resources:
          limits:
            cpu: 100m
            memory: 1G
          requests:
            cpu: 50m
            memory: 512M
    ```

    If you would like to build an image from an hosted zip or jar:

    ```yaml
    apiVersion: build.pivotal.io/v1alpha1
    kind: Image
    metadata:
      name: sample-image
      namespace: build-namespace
    spec:
      tag: gcr.io/project-name/app
      serviceAccount: service-account
      builder:
        name: sample-builder
        kind: ClusterBuilder
      cacheSize: "1.5Gi" # Optional, if not set then the caching feature is disabled
      failedBuildHistoryLimit: 5 # Optional, if not present defaults to 10
      successBuildHistoryLimit: 5 # Optional, if not present defaults to 10
      source:
        blob:
          url: https://storage.googleapis.com/build-service/sample-apps/spring-petclinic-2.1.0.BUILD-SNAPSHOT.jar
      build: # Optional
        env:
          - name: BP_JAVA_VERSION
            value: 8.*
        resources:
          limits:
            cpu: 100m
            memory: 1G
          requests:
            cpu: 50m
            memory: 512M
    ```